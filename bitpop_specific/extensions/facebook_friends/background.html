<html>
<head>
  <title>Facebook Connect For Chrome Extension</title>

  <script type="text/javascript" src="js/autolink-min.js"></script>
  <script type="text/javascript" src="js/common.js"></script>
  <script>
    var friendList = null;
    var myUid = null;
    var statuses = {};
    var inboxData = null;

    //chrome.extension.sendRequest(bitpop.CONTROLLER_EXTENSION_ID,
    //  { type: 'observe',
    //    extensionId: chrome.i18n.getMessage('@@extension_id')
    //  });

    (function () {
      if (chrome.browserAction)
        chrome.browserAction.onClicked.addListener(function (tab) {
          chrome.chromePrivate.getFriendsSidebarVisible(function(is_visible) {
            chrome.chromePrivate.setFriendsSidebarVisible(!is_visible);
          });
        });
      else
        setTimeout(arguments.callee, 1000);
    })();

    chrome.extension.onRequestExternal.addListener(function (request, sender, sendResponse) {
      if (!request.type)
        return;

      if (request.type == 'myUidAvailable') {
          myUid = request.myUid;
          sendInboxRequest();
      } else if (request.type == 'friendListReceived') {
        friendList = request.data;
      } else if (request.type == 'loggedOut') {
        friendList = null;
      } else if (request.type == 'userStatusChanged') {
        // send change status message: empty message body signals to only check
        // for status change
        chrome.chromePrivate.newIncomingMessage(request.uid, "",
            request.status, "");

        // set global variable storing each user status, reported by XMPP
        statuses[request.uid.toString()] = request.status;

      } else if (request.type == 'newMessage') {
        var msgDate = new Date();  // set 'now' as the message arrive time

        console.assert(myUid != null);

        bitpop.saveToLocalStorage(myUid, request.from,
          bitpop.preprocessMessageText(request.body),
          msgDate,
          false);

        var found = false;
        var vs = chrome.extension.getViews();
        for (var i = 0; i < vs.length; ++i) {
          if (vs[i].location.hash.slice(1) == request.from) {
            found = true;
            break;
          }
        }

        if (!found) {
          for (var i = 0; i < friendList.length; ++i) {
            if (friendList[i].uid == request.from) {
              // use status from fql result first,
              // then from xmpp server status update,
              // else set it to offline
              var status = null;
              if (friendList[i].online_presence !== null)
                status = friendList[i].online_presence;
              else if (statuses[friendList[i].uid.toString()])
                status = statuses[friendList[i].uid.toString()];
              else
                status = 'offline';

              chrome.chromePrivate.newIncomingMessage(
                                 friendList[i].uid.toString(),
                                 friendList[i].name,
                                 status,
                                 request.body);
              break;
            }
          }
        }
      }
    });
    
    function sendInboxRequest() {
      chrome.extension.sendRequest(bitpop.CONTROLLER_EXTENSION_ID,
        { type: 'graphApiCall',
          path: '/me/inbox',
          params: {}
        },
        function (response) {
          inboxData = response.data;
          replaceLocalHistory(inboxData);
        }
      );
    }

    function replaceLocalHistory(data) {
      console.assert(myUid != null);
      console.assert(data != null);

      for (var i = 0; i < data.length; i++) {
        var from_id = data[i].from.id;
        var to_ids = [];
        for (var j = 0; j < data[i].to.data.length; j++) {
          to_ids.push(data[i].to.data[j].id);
          if (to_ids[j] == myUid) // exclude my uid from to_ids list
            to_ids.pop();
        }

        if (to_ids.length > 1)
          return;
        var jid = myUid + ':' + to_ids[0].toString();
        localStorage.removeItem(jid);

        for (var j = 0; j < data[i].comments.data.length; j++) {
          bitpop.saveToLocalStorage(myUid, to_ids[0], 
              bitpop.preprocessMessageText(data[i].comments.data[j].message),
              j, // TODO: set timestamp as required
              data[i].comments.data[j].from.id == myUid
          );
        }
      }
    }

  </script>
</head>
<body>
</body>
</html>
